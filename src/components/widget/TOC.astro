---
// src/components/widget/TOC.astro
import type { MarkdownHeading } from 'astro';
import { siteConfig } from "../../config";

interface Props {
  class?: string;
  headings: MarkdownHeading[];
}

const { headings = [], class: className } = Astro.props;
const maxLevel = siteConfig.toc.depth;
const minDepth = Math.min(...headings.map(h => h.depth), 10);
const filteredHeadings = headings.filter(h => h.depth < minDepth + maxLevel);

const removeTrailingHash = (text: string) => text.replace(/#+$/, '');

let heading1Count = 1;
---
<table-of-contents class:list={[className, "group"]}>
  {filteredHeadings.map((heading) => {
    const levelOffset = heading.depth - minDepth;
    const badgeContent = levelOffset === 0 ? 
      heading1Count++ : 
      levelOffset === 1 ? 
        <div class="toc-badge-dot" /> : 
        <div class="toc-badge-small-dot" />;

    return (
      <a 
        href={`#${heading.slug}`} 
        class="toc-link"
        data-depth={levelOffset}
      >
        <div class={[
          "toc-badge",
          levelOffset === 0 && "toc-badge-primary",
          levelOffset === 1 && "ml-4",
          levelOffset === 2 && "ml-8"
        ]}>
          {badgeContent}
        </div>
        <div class={[
          "toc-text",
          levelOffset <= 1 && "text-50",
          levelOffset === 2 && "text-30"
        ]}>
          {removeTrailingHash(heading.text)}
        </div>
      </a>
    );
  })}
  <div 
    id="active-indicator" 
    class:list={[
      headings.length === 0 && 'hidden',
      "toc-active-indicator"
    ]}
  />
</table-of-contents>

<script is:inline>
// Penanganan registrasi komponen global yang kompatibel
(function() {
  if (window.__toc_registered) return;
  
  class TableOfContents extends HTMLElement {
    constructor() {
      super();
      this.observer = new IntersectionObserver(this.handleIntersection.bind(this), { 
        threshold: 0.1,
        rootMargin: '0px 0px -50% 0px'
      });
      
      this.tocEntries = [];
      this.activeSections = [];
      this.cleanupFns = [];
    }

    handleIntersection(entries) {
      entries.forEach(entry => {
        const heading = entry.target.querySelector('h1,h2,h3,h4,h5,h6');
        const index = this.tocEntries.findIndex(a => 
          a.hash === `#${heading?.id}`
        );
        if (index > -1) this.activeSections[index] = entry.isIntersecting;
      });
      this.updateActiveState();
    }

    updateActiveState() {
      const activeIndexes = this.activeSections
        .map((active, index) => active ? index : -1)
        .filter(i => i > -1);
      
      this.tocEntries.forEach(entry => entry.classList.remove('active'));
      activeIndexes.forEach(i => this.tocEntries[i].classList.add('active'));
      
      this.updateActiveIndicator(activeIndexes);
      this.scrollToVisibleSection(activeIndexes);
    }

    updateActiveIndicator(indexes) {
      const indicator = this.querySelector('#active-indicator');
      if (!indicator || !indexes.length) return;

      const first = this.tocEntries[indexes[0]];
      const last = this.tocEntries[indexes[indexes.length - 1]];
      const top = first.offsetTop;
      const height = last.offsetTop + last.offsetHeight - top;

      indicator.style.transform = `translateY(${top}px)`;
      indicator.style.height = `${height}px`;
    }

    scrollToVisibleSection(indexes) {
      if (!indexes.length || !this.tocEntries[indexes[0]]) return;
      
      const target = this.tocEntries[indexes[0]];
      const { offsetTop, offsetHeight } = target;
      const { scrollTop, clientHeight } = this;
      
      if (offsetTop < scrollTop || offsetTop + offsetHeight > scrollTop + clientHeight) {
        this.scrollTo({
          top: offsetTop - clientHeight * 0.3,
          behavior: 'smooth'
        });
      }
    }

    connectedCallback() {
      this.tocEntries = Array.from(this.querySelectorAll('a[href^="#"]'));
      this.sectionElements = this.tocEntries
        .map(a => document.querySelector(a.hash)?.closest('section'))
        .filter(Boolean);
      
      this.activeSections = new Array(this.tocEntries.length).fill(false);
      this.sectionElements.forEach(section => 
        this.observer.observe(section)
      );

      const clickHandler = (e) => {
        const anchor = e.target.closest('a');
        if (anchor?.hash) {
          const target = document.querySelector(anchor.hash);
          target?.scrollIntoView({ behavior: 'smooth' });
        }
      };
      
      this.addEventListener('click', clickHandler);
      this.cleanupFns.push(() => 
        this.removeEventListener('click', clickHandler)
      );
    }

    disconnectedCallback() {
      this.observer.disconnect();
      this.cleanupFns.forEach(fn => fn());
    }
  }

  // Registrasi dengan pengecekan environment
  if (!customElements.get('table-of-contents')) {
    customElements.define('table-of-contents', TableOfContents);
    window.__toc_registered = true;
  }
})();
</script>

<style>
.toc-link {
  @apply px-2 flex gap-2 relative transition w-full min-h-9 rounded-xl
    hover:bg-[var(--toc-btn-hover)] active:bg-[var(--toc-btn-active)] py-2;
}

.toc-badge {
  @apply transition w-5 h-5 shrink-0 rounded-lg text-xs flex items-center justify-center font-bold
    bg-[var(--toc-badge-bg)] text-[var(--btn-content)];
}

.toc-badge-dot {
  @apply w-2 h-2 rounded-[0.1875rem] bg-[var(--toc-badge-bg)];
}

.toc-badge-small-dot {
  @apply w-1.5 h-1.5 rounded-sm bg-black/5 dark:bg-white/10;
}

.toc-active-indicator {
  @apply -z-10 absolute bg-[var(--toc-btn-hover)] rounded-xl transition-all
    group-hover:bg-transparent border-2 border-[var(--toc-btn-hover)] 
    group-hover:border-[var(--toc-btn-active)] border-dashed;
}
</style>
